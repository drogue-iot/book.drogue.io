<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Embassy layer by layer :: Drogue IoT</title>
    <meta name="generator" content="Antora 3.0.1">
    <link rel="stylesheet" href="../../_/css/site.css">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-Z4BRXRBJJ1"></script>
    <script>function gtag(){dataLayer.push(arguments)};window.dataLayer=window.dataLayer||[];gtag('js',new Date());gtag('config','G-Z4BRXRBJJ1')</script>
    <script>var uiRootPath = '../../_'</script>
    <link rel="icon" href="../../_/img/favicon.svg" type="image/svg+xml">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">

      <a class="navbar-item" href="../..">
        <img class="navbar-brand-image" src="../../_/img/logo.png" alt="Drogue IoT"/>
      </a>
        <div class="navbar-item search hide-for-print">
          <div id="search-field" class="field">
            <input id="search-input" type="text" placeholder="Search the docs">
          </div>
        </div>

      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://www.drogue.io" target="_blank">Project</a>
        <a class="navbar-item" href="https://blog.drogue.io" target="_blank">Blog</a>
        <a class="navbar-item" href="https://matrix.to/#/#drogue-iot:matrix.org" target="_blank">Chat</a>
        <a class="navbar-item" href="https://book.drogue.io">Documentation</a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="embassy" data-version="dev">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="index.html">Embassy</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="runtime.html">Runtime</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="traits.html">APIs</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="hal.html">Hardware Abstraction Layer</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="nrf.html">nRF</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="stm32.html">STM32</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="bootloader.html">Bootloader</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="getting_started.html">Getting started</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="basic_application.html">Basic application</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="layer_by_layer.html">Layer by Layer</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="examples.html">Examples</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Embassy</span>
    <span class="version">dev</span>
  </div>
  <ul class="components">
    <li class="component">
      <a class="title" href="../../drogue-cloud/dev/index.html">Drogue Cloud</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../drogue-cloud/dev/index.html">dev</a>
        </li>
        <li class="version">
          <a href="../../drogue-cloud/0.9/index.html">0.9</a>
        </li>
        <li class="version">
          <a href="../../drogue-cloud/0.8/index.html">0.8</a>
        </li>
        <li class="version">
          <a href="../../drogue-cloud/0.7/index.html">0.7</a>
        </li>
        <li class="version">
          <a href="../../drogue-cloud/0.6/index.html">0.6</a>
        </li>
        <li class="version">
          <a href="../../drogue-cloud/0.5/index.html">0.5</a>
        </li>
        <li class="version">
          <a href="../../drogue-cloud/0.4/index.html">0.4</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../drogue-device/dev/index.html">Drogue Device</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../drogue-device/dev/index.html">dev</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../drogue-book/index.html">Drogue IoT</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../drogue-book/index.html">master</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../drogue-workshops/index.html">Drogue IoT Workshops</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../drogue-workshops/index.html">master</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <a class="title" href="index.html">Embassy</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="index.html">dev</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../drogue-book/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">Embassy</a></li>
    <li><a href="getting_started.html">Getting started</a></li>
    <li><a href="layer_by_layer.html">Layer by Layer</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/embassy-rs/embassy/edit/master/docs/modules/ROOT/pages/layer_by_layer.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Embassy layer by layer</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>If you&#8217;re new to Embassy, it can be overwhelming to grasp all the terminology and concepts. This guide aims to clarify the different layers in Embassy, which problem each layer solves for the application writer.</p>
</div>
<div class="paragraph">
<p>This guide uses the STM32 IOT01A board, but should be easy to translate to any STM32 chip. For nRF, the PAC itself is not maintained within the Embassy project, but the concepts and the layers are similar.</p>
</div>
<div class="paragraph">
<p>The application we&#8217;ll write is a simple 'push button, blink led' application, which is great for illustrating input and output handling for each of the examples we&#8217;ll go through. We&#8217;ll start at the Peripheral Access Crate (PAC) example and end at the async example.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pac_version"><a class="anchor" href="#_pac_version"></a>PAC version</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The PAC is the lowest API for accessing peripherals and registers, if you don&#8217;t count reading/writing directly to memory addresses. It provide distinct types
to make accessing peripheral registers easier, but it does not prevent you from writing unsafe code.</p>
</div>
<div class="paragraph">
<p>Writing an application using the PAC directly is therefore not recommended, but if the functionality you want to use is not exposed in the upper layers, that&#8217;s what you need to use.</p>
</div>
<div class="paragraph">
<p>The blinky app using PAC is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">#![no_std]
#![no_main]

use pac::gpio::vals;
use {defmt_rtt as _, panic_probe as _, stm32_metapac as pac};

#[cortex_m_rt::entry]
fn main() -&gt; ! {
    // Enable GPIO clock
    let rcc = pac::RCC;
    unsafe {
        rcc.ahb2enr().modify(|w| {
            w.set_gpioben(true);
            w.set_gpiocen(true);
        });

        rcc.ahb2rstr().modify(|w| {
            w.set_gpiobrst(true);
            w.set_gpiocrst(true);
            w.set_gpiobrst(false);
            w.set_gpiocrst(false);
        });
    }

    // Setup button
    let gpioc = pac::GPIOC;
    const BUTTON_PIN: usize = 13;
    unsafe {
        gpioc.pupdr().modify(|w| w.set_pupdr(BUTTON_PIN, vals::Pupdr::PULLUP));
        gpioc.otyper().modify(|w| w.set_ot(BUTTON_PIN, vals::Ot::PUSHPULL));
        gpioc.moder().modify(|w| w.set_moder(BUTTON_PIN, vals::Moder::INPUT));
    }

    // Setup LED
    let gpiob = pac::GPIOB;
    const LED_PIN: usize = 14;
    unsafe {
        gpiob.pupdr().modify(|w| w.set_pupdr(LED_PIN, vals::Pupdr::FLOATING));
        gpiob.otyper().modify(|w| w.set_ot(LED_PIN, vals::Ot::PUSHPULL));
        gpiob.moder().modify(|w| w.set_moder(LED_PIN, vals::Moder::OUTPUT));
    }

    // Main loop
    loop {
        unsafe {
            if gpioc.idr().read().idr(BUTTON_PIN) == vals::Idr::LOW {
                gpiob.bsrr().write(|w| w.set_bs(LED_PIN, true));
            } else {
                gpiob.bsrr().write(|w| w.set_br(LED_PIN, true));
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, there are a lot of code needed to enable the peripheral clocks, configuring the input pins and the output pins of the application.</p>
</div>
<div class="paragraph">
<p>Another downside of this application is that it is busy-looping while polling the button state. This prevents the microcontroller from utilizing any sleep mode to save power.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hal_version"><a class="anchor" href="#_hal_version"></a>HAL version</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To simplify our application, we can use the HAL instead. The HAL exposes higher level APIs that handle details such</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Automatically enabling the peripheral clock when you&#8217;re using the peripheral</p>
</li>
<li>
<p>Deriving and applying register configuration from higher level types</p>
</li>
<li>
<p>Implementing the embedded-hal traits to make peripherals useful in third party drivers</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The HAL example is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">#![no_std]
#![no_main]

use cortex_m_rt::entry;
use embassy_stm32::gpio::{Input, Level, Output, Pull, Speed};
use {defmt_rtt as _, panic_probe as _};

#[entry]
fn main() -&gt; ! {
    let p = embassy_stm32::init(Default::default());
    let mut led = Output::new(p.PB14, Level::High, Speed::VeryHigh);
    let button = Input::new(p.PC13, Pull::Up);

    loop {
        if button.is_low() {
            led.set_high();
        } else {
            led.set_low();
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, the application becomes a lot simpler, even without using any async code. The <code>Input</code> and <code>Output</code> hides all the details accessing the GPIO registers, and allow you to use a much simpler API to query the state of the button and toggle the LED output accordingly.</p>
</div>
<div class="paragraph">
<p>The same downside from the PAC example still applies though: the application is busy looping and consuming more power than necessary.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_interrupt_driven"><a class="anchor" href="#_interrupt_driven"></a>Interrupt driven</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To save power, we need to configure the application so that it can be notified when the button is pressed using an interrupt.</p>
</div>
<div class="paragraph">
<p>Once the interrupt is configured, the application can instruct the microcontroller to enter a sleep mode, consuming very little power.</p>
</div>
<div class="paragraph">
<p>Given Embassy focus on async Rust (which we&#8217;ll come back to after this example), the example application must use a combination of the HAL and PAC in order to use interrupts. For this reason, the application also contains some helper functions to access the PAC (not shown below).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">#![no_std]
#![no_main]

use core::cell::RefCell;

use cortex_m::interrupt::Mutex;
use cortex_m::peripheral::NVIC;
use cortex_m_rt::entry;
use embassy_stm32::gpio::{Input, Level, Output, Pin, Pull, Speed};
use embassy_stm32::peripherals::{PB14, PC13};
use embassy_stm32::{interrupt, pac};
use {defmt_rtt as _, panic_probe as _};

static BUTTON: Mutex&lt;RefCell&lt;Option&lt;Input&lt;'static, PC13&gt;&gt;&gt;&gt; = Mutex::new(RefCell::new(None));
static LED: Mutex&lt;RefCell&lt;Option&lt;Output&lt;'static, PB14&gt;&gt;&gt;&gt; = Mutex::new(RefCell::new(None));

#[entry]
fn main() -&gt; ! {
    let p = embassy_stm32::init(Default::default());
    let led = Output::new(p.PB14, Level::Low, Speed::Low);
    let mut button = Input::new(p.PC13, Pull::Up);

    cortex_m::interrupt::free(|cs| unsafe {
        enable_interrupt(&amp;mut button);

        LED.borrow(cs).borrow_mut().replace(led);
        BUTTON.borrow(cs).borrow_mut().replace(button);

        NVIC::unmask(pac::Interrupt::EXTI15_10);
    });

    loop {
        cortex_m::asm::wfe();
    }
}

#[interrupt]
fn EXTI15_10() {
    cortex_m::interrupt::free(|cs| {
        let mut button = BUTTON.borrow(cs).borrow_mut();
        let button = button.as_mut().unwrap();

        let mut led = LED.borrow(cs).borrow_mut();
        let led = led.as_mut().unwrap();
        if check_interrupt(button) {
            if button.is_low() {
                led.set_high();
            } else {
                led.set_low();
            }
        }
        clear_interrupt(button);
    });
}
//
//
//</code></pre>
</div>
</div>
<div class="paragraph">
<p>The simple application is now more complex again, primarily because of the need to keep the button and LED states in the global scope where it is accessible by the main application loop, as well as the interrupt handler.</p>
</div>
<div class="paragraph">
<p>To do that, the types must be guarded by a mutex, and interrupts must be disabled whenever we are accessing this global state to gain access to the peripherals.</p>
</div>
<div class="paragraph">
<p>Luckily, there is an elegant solution to this problem when using Embassy.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_async_version"><a class="anchor" href="#_async_version"></a>Async version</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It&#8217;s time to use the Embassy capabilities to its fullest. At the core, Embassy has an async excecutor, or a runtime for async tasks if you will. The executor polls a set of tasks (defined at compile time), and whenever a task <code>blocks</code>, the executor will run another task, or put the microcontroller to sleep.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">#![no_std]
#![no_main]
#![feature(type_alias_impl_trait)]

use embassy::executor::Spawner;
use embassy_stm32::exti::ExtiInput;
use embassy_stm32::gpio::{Input, Level, Output, Pull, Speed};
use embassy_stm32::Peripherals;
use {defmt_rtt as _, panic_probe as _};

#[embassy::main]
async fn main(_s: Spawner, p: Peripherals) {
    let mut led = Output::new(p.PB14, Level::Low, Speed::VeryHigh);
    let mut button = ExtiInput::new(Input::new(p.PC13, Pull::Up), p.EXTI13);

    loop {
        button.wait_for_any_edge().await;
        if button.is_low() {
            led.set_high();
        } else {
            led.set_low();
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The async version looks very similar to the HAL version, apart from a few minor details:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The main entry point is annotated with a different macro and has an async type signature. This macro creates and starts an Embassy runtime instance and launches the main application task. Using the <code>Spawner</code> instance, the application may spawn other tasks.</p>
</li>
<li>
<p>The peripheral initialization is done by the main macro, and is handed to the main task.</p>
</li>
<li>
<p>Before checking the button state, the application is awaiting a transition in the pin state (low &#8594; high or high &#8594; low).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When <code>button.await_for_any_edge().await</code> is called, the executor will pause the main task and put the microcontroller in sleep mode, unless there are other tasks that can run. Internally, the Embassy HAL has configured the interrupt handler for the button (in <code>ExtiButton</code>), so that whenever an interrupt is raised, the task awaiting the button will be woken up.</p>
</div>
<div class="paragraph">
<p>The minimal overhead of the executor and the ability to run multiple tasks "concurrently" combined with the enormous simplification of the application, makes <code>async</code> a great fit for embedded.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_summary"><a class="anchor" href="#_summary"></a>Summary</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We have seen how the same application can be written at the different abstraction levels in Embassy. First starting out at the PAC level, then using the HAL, then using interrupts, and then using interrupts indirectly using async Rust.</p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using a modified version of the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../_/js/site.js"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
<script src="../../_/js/vendor/lunr.js"></script>
<script src="../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../.." data-snippet-length="100" data-stylesheet="../../_/css/search.css"></script>
<script async src="../../search-index.js"></script>
  </body>
</html>
